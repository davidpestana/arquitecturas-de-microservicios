# 4.1 â€“ CQRS: Comandos y Consultas

---

## ğŸ¯ Objetivo

Comprender el patrÃ³n **CQRS (Command Query Responsibility Segregation)**, su motivaciÃ³n dentro de arquitecturas de microservicios y cÃ³mo separa las responsabilidades de lectura y escritura para mejorar el rendimiento, la escalabilidad y la mantenibilidad del sistema.

---

## ğŸ§© Concepto

Tradicionalmente, en una aplicaciÃ³n monolÃ­tica usamos el **mismo modelo** y la **misma base de datos** para leer y escribir informaciÃ³n:

```js
app.post("/pedido", crearPedido);
app.get("/pedido/:id", obtenerPedido);
```

Esto es simple, pero genera **limitaciones** en sistemas distribuidos:

* Dificulta escalar la lectura y escritura de forma independiente.
* Mezcla responsabilidades de lÃ³gica de negocio.
* Aumenta el riesgo de bloqueos o inconsistencias cuando hay muchos servicios accediendo al mismo modelo.

ğŸ‘‰ **CQRS propone separarlas completamente.**

---

## âš™ï¸ Principio CQRS

> **Command Query Responsibility Segregation (CQRS)**:
> Separar las operaciones de **lectura (Query)** y **escritura (Command)** en diferentes modelos o servicios.

| Tipo        | PropÃ³sito          | Ejemplo                       | Efecto sobre el sistema |
| ----------- | ------------------ | ----------------------------- | ----------------------- |
| **Command** | Ejecuta una acciÃ³n | Crear pedido, aprobar factura | âœ… Modifica el estado    |
| **Query**   | Consulta datos     | Obtener pedidos del cliente   | âŒ No cambia el estado   |

---

## ğŸ§­ Flujo general


```mermaid
graph TD
  A[Cliente/API] -->|POST /pedido| B[Command Service]
  B -->|Evento pedido_creado| C[(Event Bus)]
  C --> D[Query Service]
  D -->|Datos actualizados| E[(Read Model)]
  A -->|GET /pedidos| D
```

* ğŸŸ¦ **Command Service:** recibe y valida acciones de negocio.
* ğŸŸ§ **Query Service:** mantiene una vista actualizada para consultas.
* âš™ï¸ **Event Bus:** comunica ambos mundos de forma asÃ­ncrona.

---

## ğŸ§± Beneficios del enfoque CQRS

| Beneficio                       | DescripciÃ³n                                                                      |
| ------------------------------- | -------------------------------------------------------------------------------- |
| **Escalabilidad independiente** | Podemos escalar lecturas y escrituras por separado.                              |
| **Rendimiento optimizado**      | La lectura puede usar un modelo simplificado (cache, Redis, materialized viewâ€¦). |
| **Mantenibilidad**              | CÃ³digo mÃ¡s claro, modelos mÃ¡s simples.                                           |
| **Flexibilidad tecnolÃ³gica**    | Se pueden usar diferentes bases de datos o lenguajes por lado.                   |
| **AuditorÃ­a natural**           | Las acciones se modelan como eventos explÃ­citos.                                 |

---

## ğŸ” ComparaciÃ³n visual

```mermaid
flowchart LR
  subgraph MonolÃ­tico
    A1[API] --> M1[(Modelo Ãºnico)]
  end
  subgraph CQRS
    A2[Command Service] -->|evento| B2[(Event Store)]
    A3[Query Service] -->|consulta| C2[(Read Model)]
  end
```

*ğŸ”¹ En un modelo tradicional, las consultas y comandos comparten el mismo modelo.
*ğŸ”¹ En CQRS, se separan las responsabilidades y se comunican por eventos.

---

## ğŸ’¡ Ejemplo funcional (Node.js + RabbitMQ)

En este ejemplo, implementamos **dos microservicios** con un **bus de eventos**.

---

### ğŸŸ¦ 1. Servicio de comandos (`commands-service`)

Recibe solicitudes para crear pedidos y publica eventos al bus.

```js
import express from "express";
import amqp from "amqplib";

const app = express();
app.use(express.json());

async function publicarEvento(evento) {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();
  const exchange = "eventos_pedidos";
  await ch.assertExchange(exchange, "fanout", { durable: true });
  ch.publish(exchange, "", Buffer.from(JSON.stringify(evento)));
  console.log(`ğŸ“¤ Evento publicado: ${evento.tipo}`);
  await ch.close();
  await conn.close();
}

app.post("/pedido", async (req, res) => {
  const pedido = {
    id: Date.now(),
    cliente: req.body.cliente,
    total: req.body.total,
    estado: "CREADO"
  };
  await publicarEvento({ tipo: "pedido_creado", data: pedido });
  res.json({ status: "ok", pedido });
});

app.listen(5000, () => console.log("ğŸŸ¢ Commands Service en puerto 5000"));
```

---

### ğŸŸ§ 2. Servicio de consultas (`queries-service`)

Escucha los eventos y mantiene una vista en memoria de los pedidos creados.

```js
import express from "express";
import amqp from "amqplib";

const app = express();
let pedidos = [];

async function escucharEventos() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();
  const exchange = "eventos_pedidos";
  await ch.assertExchange(exchange, "fanout", { durable: true });

  const q = await ch.assertQueue("cola_pedidos");
  await ch.bindQueue(q.queue, exchange, "");

  console.log("ğŸ“¥ Escuchando eventos de pedidos...");

  ch.consume(q.queue, msg => {
    const evento = JSON.parse(msg.content.toString());
    if (evento.tipo === "pedido_creado") {
      pedidos.push(evento.data);
      console.log(`ğŸŸ  Pedido registrado: ${evento.data.id}`);
    }
    ch.ack(msg);
  });
}

app.get("/pedidos", (req, res) => res.json(pedidos));

escucharEventos();
app.listen(5001, () => console.log("ğŸŸ¢ Queries Service en puerto 5001"));
```

---

## ğŸ§ª Prueba rÃ¡pida del flujo

Con RabbitMQ y ambos servicios corriendo:

1ï¸âƒ£ Crear pedido (comando):

```bash
curl -X POST http://localhost:5000/pedido \
  -H "Content-Type: application/json" \
  -d '{"cliente": "David", "total": 200}'
```

2ï¸âƒ£ Consultar pedidos (query):

```bash
curl http://localhost:5001/pedidos
```

âœ… VerÃ¡s el pedido creado reflejado en el servicio de lectura.

---

## ğŸ”„ InteracciÃ³n CQRS completa

```mermaid
sequenceDiagram
  participant CMD as Commands Service
  participant BUS as Event Bus
  participant QRY as Queries Service

  CMD->>BUS: ğŸ“¤ Evento "pedido_creado"
  BUS-->>QRY: ğŸ“© ReenvÃ­a evento
  QRY-->>QRY: ğŸŸ  Actualiza vista de lectura
  QRY->>Cliente: GET /pedidos â†’ datos actualizados
```

---

## âš ï¸ Consideraciones

| Reto                        | Posible soluciÃ³n                                     |
| --------------------------- | ---------------------------------------------------- |
| **Consistencia eventual**   | Aceptar pequeÃ±os retrasos entre escritura y lectura. |
| **Duplicados de eventos**   | Usar identificadores Ãºnicos o idempotencia.          |
| **SincronizaciÃ³n compleja** | Introducir `event store` o `snapshotting`.           |

---

## ğŸ’¬ AnalogÃ­a

> Imagina una tienda donde:
>
> * El **vendedor** (Command Service) anota los pedidos nuevos.
> * El **mostrador** (Query Service) solo muestra los pedidos ya confirmados.
> * Entre ambos, el **bus de eventos** actÃºa como el mensajero que pasa la informaciÃ³n.

---

## ğŸ”š ConclusiÃ³n

El patrÃ³n **CQRS** ofrece una forma clara de separar los mundos de **lectura** y **escritura**, mejorando:

* el rendimiento del sistema,
* la escalabilidad horizontal,
* y la comprensiÃ³n del cÃ³digo.

Este patrÃ³n se combina habitualmente con **Event Sourcing**, que estudiaremos en el siguiente apartado (4.2), donde cada cambio de estado se almacena como un evento histÃ³rico.
